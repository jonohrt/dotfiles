"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const find_up_1 = tslib_1.__importDefault(require("find-up"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const which_1 = tslib_1.__importDefault(require("which"));
const countRegex = /Found\s+(\d+)\s+error/;
const errorRegex = /^(.+)\((\d+),(\d+)\):\s(\w+)\sTS(\d+):\s*(.+)$/;
var TscStatus;
(function (TscStatus) {
    TscStatus[TscStatus["INIT"] = 0] = "INIT";
    TscStatus[TscStatus["COMPILING"] = 1] = "COMPILING";
    TscStatus[TscStatus["RUNNING"] = 2] = "RUNNING";
    TscStatus[TscStatus["ERROR"] = 3] = "ERROR";
})(TscStatus || (TscStatus = {}));
class WatchProject {
    constructor(commandManager) {
        this.disposables = [];
        this.statusItem = coc_nvim_1.workspace.createStatusBarItem(1, { progress: true });
        let task = this.task = coc_nvim_1.workspace.createTask('TSC');
        this.disposables.push(commandManager.registerCommand(WatchProject.id, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let opts = this.options = this.getOptions();
            yield this.start(opts);
        })));
        task.onExit(code => {
            if (code != 0) {
                coc_nvim_1.workspace.showMessage(`TSC exit with code ${code}`, 'warning');
            }
            this.onStop();
        });
        task.onStdout(lines => {
            for (let line of lines) {
                this.onLine(line);
            }
        });
        task.onStderr(lines => {
            coc_nvim_1.workspace.showMessage(`TSC error: ` + lines.join('\n'), 'error');
        });
        this.disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            task.dispose();
        }));
        this.check().catch(_e => {
            // noop
        });
    }
    check() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let running = yield this.task.running;
            if (running) {
                this.options = this.getOptions();
                this.statusItem.isProgress = false;
                this.statusItem.text = '?';
                this.statusItem.show();
            }
            else {
                this.onStop();
            }
        });
    }
    start(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.task.start(options);
        });
    }
    onStop() {
        this.statusItem.hide();
    }
    onStart() {
        this.statusItem.text = 'compiling';
        this.statusItem.isProgress = true;
        this.statusItem.show();
        coc_nvim_1.workspace.nvim.call('setqflist', [[], 'r'], true);
    }
    onLine(line) {
        if (countRegex.test(line)) {
            let ms = line.match(countRegex);
            this.statusItem.text = ms[1] == '0' ? '✓' : '✗';
            this.statusItem.isProgress = false;
        }
        else if (WatchProject.startTexts.findIndex(s => line.indexOf(s) !== -1) != -1) {
            this.onStart();
        }
        else {
            let ms = line.match(errorRegex);
            if (!ms)
                return;
            let fullpath = path_1.default.join(this.options.cwd, ms[1]);
            let uri = vscode_uri_1.default.file(fullpath).toString();
            let doc = coc_nvim_1.workspace.getDocument(uri);
            let bufnr = doc ? doc.bufnr : null;
            let item = {
                filename: fullpath,
                lnum: Number(ms[2]),
                col: Number(ms[3]),
                text: `[tsc ${ms[5]}] ${ms[6]}`,
                type: /error/i.test(ms[4]) ? 'E' : 'W'
            };
            if (bufnr)
                item.bufnr = bufnr;
            coc_nvim_1.workspace.nvim.call('setqflist', [[item], 'a']);
        }
    }
    getOptions() {
        let res = find_up_1.default.sync(['node_modules'], { cwd: coc_nvim_1.workspace.root });
        let root;
        let cmd;
        // let root: string
        if (!res) {
            if (executable('tsc')) {
                cmd = 'tsc';
                root = coc_nvim_1.workspace.cwd;
            }
        }
        else {
            let file = path_1.default.join(path_1.default.dirname(res), 'node_modules/.bin/tsc');
            if (fs_1.default.existsSync(file)) {
                cmd = './node_modules/.bin/tsc';
                root = path_1.default.dirname(res);
            }
        }
        if (!cmd) {
            coc_nvim_1.workspace.showMessage(`Local & global tsc not found`, 'error');
            return;
        }
        let find = find_up_1.default.sync(['tsconfig.json'], { cwd: root });
        if (!find) {
            coc_nvim_1.workspace.showMessage('tsconfig.json not found!', 'error');
            return;
        }
        let configRoot = path_1.default.dirname(find);
        let configPath = path_1.default.relative(root, path_1.default.join(configRoot, 'tsconfig.json'));
        return {
            cmd,
            args: ['-p', configPath, '--watch', 'true', '--pretty', 'false'],
            cwd: root
        };
    }
    dispose() {
        coc_nvim_1.disposeAll(this.disposables);
    }
}
WatchProject.id = 'tsserver.watchBuild';
WatchProject.startTexts = ['Starting compilation in watch mode', 'Starting incremental compilation'];
exports.default = WatchProject;
function executable(command) {
    try {
        which_1.default.sync(command);
    }
    catch (e) {
        return false;
    }
    return true;
}
//# sourceMappingURL=watchBuild.js.map