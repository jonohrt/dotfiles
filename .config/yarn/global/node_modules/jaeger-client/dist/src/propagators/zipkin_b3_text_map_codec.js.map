{"version":3,"sources":["../../../src/propagators/zipkin_b3_text_map_codec.js"],"names":["constants","ZIPKIN_PARENTSPAN_HEADER","ZIPKIN_SPAN_HEADER","ZIPKIN_TRACE_HEADER","ZIPKIN_SAMPLED_HEADER","ZIPKIN_FLAGS_HEADER","ZipkinB3TextMapCodec","options","_urlEncoding","urlEncoding","_baggagePrefix","baggagePrefix","TRACER_BAGGAGE_HEADER_PREFIX","toLowerCase","_metrics","metrics","value","encodeURIComponent","indexOf","_decodeURIValue","isNaN","parseInt","decodeURIComponent","e","carrier","baggage","flags","debugId","parentId","spanId","traceId","key","hasOwnProperty","lowerKey","_decodeValue","SAMPLED_MASK","DEBUG_MASK","JAEGER_DEBUG_HEADER","JAEGER_BAGGAGE_HEADER","startsWith","keyWithoutPrefix","substring","length","_isValidZipkinId","decodingErrors","increment","withStringIds","spanContext","traceIdStr","parentIdStr","spanIdStr","isDebug","isSampled","_encodeValue"],"mappings":"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","file":"zipkin_b3_text_map_codec.js","sourcesContent":["// @flow\n// Copyright (c) 2017 The Jaeger Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport * as constants from '../constants.js';\nimport Metrics from '../metrics/metrics.js';\nimport NoopMetricFactory from '../metrics/noop/metric_factory';\nimport SpanContext from '../span_context.js';\nimport Utils from '../util.js';\nimport { parseCommaSeparatedBaggage } from '../propagators/baggage';\n\nconst ZIPKIN_PARENTSPAN_HEADER = 'x-b3-parentspanid';\nconst ZIPKIN_SPAN_HEADER = 'x-b3-spanid';\nconst ZIPKIN_TRACE_HEADER = 'x-b3-traceid';\nconst ZIPKIN_SAMPLED_HEADER = 'x-b3-sampled';\nconst ZIPKIN_FLAGS_HEADER = 'x-b3-flags';\n\nexport default class ZipkinB3TextMapCodec {\n  _urlEncoding: boolean;\n  _baggagePrefix: string;\n  _metrics: any;\n\n  constructor(options: any = {}) {\n    this._urlEncoding = !!options.urlEncoding;\n    this._baggagePrefix = options.baggagePrefix || constants.TRACER_BAGGAGE_HEADER_PREFIX;\n    this._baggagePrefix = this._baggagePrefix.toLowerCase();\n    this._metrics = options.metrics || new Metrics(new NoopMetricFactory());\n  }\n\n  _encodeValue(value: string): string {\n    if (this._urlEncoding) {\n      return encodeURIComponent(value);\n    }\n\n    return value;\n  }\n\n  _decodeValue(value: string): string {\n    // only use url-decoding if there are meta-characters '%'\n    if (this._urlEncoding && value.indexOf('%') > -1) {\n      return this._decodeURIValue(value);\n    }\n\n    return value;\n  }\n\n  _isValidZipkinId(value: string): boolean {\n    // Validates a zipkin trace/spanID by attempting to parse it as a\n    // string of hex digits. This \"validation\" is not entirely rigorous,\n    // but equivalent to what is performed in the TextMapCodec.\n    //\n    // Note: due to the way parseInt works, this does not guarantee that\n    // the string is composed *entirely* of hex digits.\n    //\n    // > If parseInt encounters a character that is not a numeral in the\n    // > specified radix, it ignores it and all succeeding characters and\n    // > returns the integer value parsed up to that point.\n    //\n    // Note: The Number type in JS cannot represent the full range of 64bit\n    // unsigned ints, so using parseInt() on strings representing 64bit hex\n    // numbers only returns an approximation of the actual value.\n    // Fortunately, we do not depend on the returned value, we are only\n    // using it to validate that the string is a valid hex number (which is\n    // faster than doing it manually).  We cannot use\n    // Int64(numberValue).toBuffer() because it throws exceptions on bad\n    // strings.\n    if (!value) {\n      return true;\n    }\n\n    return !isNaN(parseInt(value, 16));\n  }\n\n  _decodeURIValue(value: string): string {\n    // unfortunately, decodeURIComponent() can throw 'URIError: URI malformed' on bad strings\n    try {\n      return decodeURIComponent(value);\n    } catch (e) {\n      return value;\n    }\n  }\n\n  extract(carrier: any): ?SpanContext {\n    let baggage = {};\n    let flags = 0;\n    let debugId = '';\n    let parentId = '';\n    let spanId = '';\n    let traceId = '';\n\n    for (let key in carrier) {\n      if (carrier.hasOwnProperty(key)) {\n        let lowerKey = key.toLowerCase();\n\n        switch (lowerKey) {\n          case ZIPKIN_PARENTSPAN_HEADER:\n            parentId = this._decodeValue(carrier[ZIPKIN_PARENTSPAN_HEADER]);\n            break;\n          case ZIPKIN_SPAN_HEADER:\n            spanId = this._decodeValue(carrier[ZIPKIN_SPAN_HEADER]);\n            break;\n          case ZIPKIN_TRACE_HEADER:\n            traceId = this._decodeValue(carrier[ZIPKIN_TRACE_HEADER]);\n            break;\n          case ZIPKIN_SAMPLED_HEADER:\n            flags = flags | constants.SAMPLED_MASK;\n            break;\n          case ZIPKIN_FLAGS_HEADER:\n            // Per https://github.com/openzipkin/b3-propagation\n            //   \"Debug is encoded as X-B3-Flags: 1\"\n            // and\n            //   \"Debug implies Sampled.\"\n            if (carrier[key] === '1') {\n              flags = flags | constants.SAMPLED_MASK | constants.DEBUG_MASK;\n            }\n            break;\n          case constants.JAEGER_DEBUG_HEADER:\n            debugId = this._decodeValue(carrier[constants.JAEGER_DEBUG_HEADER]);\n            break;\n          case constants.JAEGER_BAGGAGE_HEADER:\n            parseCommaSeparatedBaggage(baggage, this._decodeValue(carrier[key]));\n            break;\n          default:\n            if (Utils.startsWith(lowerKey, this._baggagePrefix)) {\n              let keyWithoutPrefix = key.substring(this._baggagePrefix.length);\n              baggage[keyWithoutPrefix] = this._decodeValue(carrier[key]);\n            }\n        }\n      }\n    }\n\n    if (\n      !this._isValidZipkinId(traceId) ||\n      !this._isValidZipkinId(spanId) ||\n      !this._isValidZipkinId(parentId)\n    ) {\n      // Use a context devoid of trace/span/parentSpan IDs (to be\n      // consistent with the default codec behavior), and increment a\n      // metric\n      traceId = spanId = parentId = '';\n      this._metrics.decodingErrors.increment(1);\n    }\n\n    return SpanContext.withStringIds(traceId, spanId, parentId, flags, baggage, debugId);\n  }\n\n  inject(spanContext: SpanContext, carrier: any): void {\n    carrier[ZIPKIN_TRACE_HEADER] = spanContext.traceIdStr;\n    carrier[ZIPKIN_PARENTSPAN_HEADER] = spanContext.parentIdStr;\n    carrier[ZIPKIN_SPAN_HEADER] = spanContext.spanIdStr;\n\n    if (spanContext.isDebug()) {\n      carrier[ZIPKIN_FLAGS_HEADER] = '1';\n    } else {\n      // Only set the zipkin sampled header if we're NOT using debug.\n      // Per https://github.com/openzipkin/b3-propagation\n      //   \"Since Debug implies Sampled, so don't also send \"X-B3-Sampled: 1\"\n      carrier[ZIPKIN_SAMPLED_HEADER] = spanContext.isSampled() ? '1' : '0';\n    }\n\n    let baggage = spanContext.baggage;\n    for (let key in baggage) {\n      if (baggage.hasOwnProperty(key)) {\n        let value = this._encodeValue(spanContext.baggage[key]);\n        carrier[`${this._baggagePrefix}${key}`] = value;\n      }\n    }\n  }\n}\n"]}