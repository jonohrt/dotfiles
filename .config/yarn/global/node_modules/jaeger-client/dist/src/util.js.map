{"version":3,"sources":["../../src/util.js"],"names":["Utils","text","prefix","indexOf","suffix","lastIndexOf","length","randint","randomint","buf","Buffer","writeUInt32BE","numberValue","toBuffer","ip","ipl","parts","split","i","parseInt","signedLimit","input","counter","charAt","substring","myIp","ifaces","networkInterfaces","keys","Object","loop1","iface","j","family","internal","address","obj","newObj","key","hasOwnProperty","dict","tags","value","push","host","port","path","success","error","get","res","setEncoding","body","on","chunk","err"],"mappings":"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","file":"util.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport xorshift from 'xorshift';\nimport Int64 from 'node-int64';\nimport os from 'os';\nimport http from 'http';\n\nexport default class Utils {\n  /**\n   * Determines whether a string contains a given prefix.\n   *\n   * @param {string} text - the string for to search for a prefix\n   * @param {string} prefix - the prefix to search for in the text given.\n   * @return {boolean} - boolean representing whether or not the\n   * string contains the prefix.\n   **/\n  static startsWith(text: string, prefix: string): boolean {\n    return text.indexOf(prefix) === 0;\n  }\n\n  /**\n   * Determines whether a string contains a given suffix.\n   *\n   * @param {string} text - the string for to search for a suffix\n   * @param {string} suffix - the suffix to search for in the text given.\n   * @return {boolean} - boolean representing whether or not the\n   * string contains the suffix.\n   **/\n  static endsWith(text: string, suffix: string): boolean {\n    return text.lastIndexOf(suffix) === text.length - suffix.length;\n  }\n\n  /**\n   * Determines whether a string contains a given prefix.\n   *\n   * @return {Buffer}  - returns a buffer representing a random 64 bit\n   * number.\n   **/\n  static getRandom64(): Buffer {\n    let randint = xorshift.randomint();\n    let buf = new Buffer(8);\n    buf.writeUInt32BE(randint[0], 0);\n    buf.writeUInt32BE(randint[1], 4);\n    return buf;\n  }\n\n  /**\n   * @param {string|number} numberValue - a string or number to be encoded\n   * as a 64 bit byte array.\n   * @return {Buffer} - returns a buffer representing the encoded string, or number.\n   **/\n  static encodeInt64(numberValue: any): any {\n    return new Int64(numberValue).toBuffer();\n  }\n\n  /**\n   * @param {string} ip - a string representation of an ip address.\n   * @return {number} - a 32-bit number where each byte represents an\n   * octect of an ip address.\n   **/\n  static ipToInt(ip: string): ?number {\n    let ipl = 0;\n    let parts = ip.split('.');\n    if (parts.length != 4) {\n      return null;\n    }\n\n    for (let i = 0; i < parts.length; i++) {\n      ipl <<= 8;\n      ipl += parseInt(parts[i], 10);\n    }\n\n    let signedLimit = 0x7fffffff;\n    if (ipl > signedLimit) {\n      return (1 << 32) - ipl;\n    }\n    return ipl;\n  }\n\n  /**\n   * @param {string} input - the input for which leading zeros should be removed.\n   * @return {string} - returns the input string without leading zeros.\n   **/\n  static removeLeadingZeros(input: string): string {\n    let counter = 0;\n    let length = input.length - 1;\n    for (let i = 0; i < length; i++) {\n      if (input.charAt(i) === '0') {\n        counter++;\n      } else {\n        break;\n      }\n    }\n\n    return input.substring(counter);\n  }\n\n  static myIp(): string {\n    let myIp = '0.0.0.0';\n    let ifaces = os.networkInterfaces();\n    let keys = Object.keys(ifaces);\n    loop1: for (let i = 0; i < keys.length; i++) {\n      let iface = ifaces[keys[i]];\n      for (let j = 0; j < iface.length; j++) {\n        if (iface[j].family === 'IPv4' && !iface[j].internal) {\n          myIp = iface[j].address;\n          break loop1;\n        }\n      }\n    }\n    return myIp;\n  }\n\n  static clone(obj: any): any {\n    let newObj = {};\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        newObj[key] = obj[key];\n      }\n    }\n\n    return newObj;\n  }\n\n  static convertObjectToTags(dict: any): Array<Tag> {\n    let tags: Array<Tag> = [];\n    for (let key in dict) {\n      let value = dict[key];\n      if (dict.hasOwnProperty(key)) {\n        tags.push({ key: key, value: value });\n      }\n    }\n\n    return tags;\n  }\n\n  static httpGet(host: string, port: number, path: string, success: Function, error: Function) {\n    http\n      .get(\n        {\n          host: host,\n          port: port,\n          path: path,\n        },\n        res => {\n          // explicitly treat incoming data as utf8 (avoids issues with multi-byte chars)\n          res.setEncoding('utf8');\n\n          // incrementally capture the incoming response body\n          let body = '';\n          res.on('data', chunk => {\n            body += chunk;\n          });\n\n          res.on('end', () => {\n            success(body);\n          });\n        }\n      )\n      .on('error', err => {\n        error(err);\n      });\n  }\n}\n"]}