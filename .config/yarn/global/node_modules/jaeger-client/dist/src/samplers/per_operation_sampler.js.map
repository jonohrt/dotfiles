{"version":3,"sources":["../../../src/samplers/per_operation_sampler.js"],"names":["constants","PerOperationSampler","strategies","maxOperations","_maxOperations","_samplersByOperation","Object","create","update","defaultLowerBoundTracesPerSecond","defaultSamplingProbability","updated","_defaultLowerBound","perOperationStrategies","forEach","operation","strategy","samplingRate","probabilisticSampling","sampler","defaultSamplingRate","_defaultSampler","name","tags","keys","length","isSampled","other","callback"],"mappings":";;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AACA;;IAAYA,S;;AACZ;;;;AACA;;;;;;;;;;AAIA;AACA;AACA;AACA;AACA;IACqBC,mB;AAMnB,+BAAYC,UAAZ,EAAwDC,aAAxD,EAA+E;AAAA;;AAC7E,SAAKC,cAAL,GAAsBD,aAAtB;AACA,SAAKE,oBAAL,GAA4BC,OAAOC,MAAP,CAAc,IAAd,CAA5B;AACA,SAAKC,MAAL,CAAYN,UAAZ;AACD;;;;2BAEMA,U,EAAqD;AAAA;;AAC1D,4BACE,OAAOA,WAAWO,gCAAlB,KAAuD,QADzD,EAEE,mEAFF;AAIA,4BACE,OAAOP,WAAWQ,0BAAlB,KAAiD,QADnD,EAEE,6DAFF;;AAKA,UAAIC,UAAmB,KAAKC,kBAAL,KAA4BV,WAAWO,gCAA9D;AACA,WAAKG,kBAAL,GAA0BV,WAAWO,gCAArC;AACAP,iBAAWW,sBAAX,CAAkCC,OAAlC,CAA0C,oBAAY;AACpD,YAAIC,YAAYC,SAASD,SAAzB;AACA,YAAIE,eAAeD,SAASE,qBAAT,CAA+BD,YAAlD;AACA,YAAIE,UAAU,MAAKd,oBAAL,CAA0BU,SAA1B,CAAd;AACA,YAAII,OAAJ,EAAa;AACX,cAAIA,QAAQX,MAAR,CAAe,MAAKI,kBAApB,EAAwCK,YAAxC,CAAJ,EAA2D;AACzDN,sBAAU,IAAV;AACD;AACF,SAJD,MAIO;AACLQ,oBAAU,4CAAgC,MAAKP,kBAArC,EAAyDK,YAAzD,CAAV;AACA,gBAAKZ,oBAAL,CAA0BU,SAA1B,IAAuCI,OAAvC;AACAR,oBAAU,IAAV;AACD;AACF,OAbD;AAcA,UAAIS,sBAAsBlB,WAAWQ,0BAArC;AACA,UAAI,CAAC,KAAKW,eAAN,IAAyB,KAAKA,eAAL,CAAqBJ,YAArB,IAAqCG,mBAAlE,EAAuF;AACrF,aAAKC,eAAL,GAAuB,oCAAyBD,mBAAzB,CAAvB;AACAT,kBAAU,IAAV;AACD;AACD,aAAOA,OAAP;AACD;;;2BAEc;AACb,aAAO,qBAAP;AACD;;;+BAEkB;AACjB,aAAU,KAAKW,IAAL,EAAV,uBAAuC,KAAKlB,cAA5C;AACD;;;8BAESW,S,EAAmBQ,I,EAAoB;AAC/C,UAAIJ,UAAmB,KAAKd,oBAAL,CAA0BU,SAA1B,CAAvB;AACA,UAAI,CAACI,OAAL,EAAc;AACZ,YAAIb,OAAOkB,IAAP,CAAY,KAAKnB,oBAAjB,EAAuCoB,MAAvC,IAAiD,KAAKrB,cAA1D,EAA0E;AACxE,iBAAO,KAAKiB,eAAL,CAAqBK,SAArB,CAA+BX,SAA/B,EAA0CQ,IAA1C,CAAP;AACD;AACDJ,kBAAU,4CAAgC,KAAKP,kBAArC,EAAyD,KAAKS,eAAL,CAAqBJ,YAA9E,CAAV;AACA,aAAKZ,oBAAL,CAA0BU,SAA1B,IAAuCI,OAAvC;AACD;AACD,aAAOA,QAAQO,SAAR,CAAkBX,SAAlB,EAA6BQ,IAA7B,CAAP;AACD;;;0BAEKI,K,EAAyB;AAC7B,aAAO,KAAP,CAD6B,CACf;AACf;;;0BAEKC,Q,EAA2B;AAC/B;AACA,UAAIA,QAAJ,EAAc;AACZA;AACD;AACF;;;;;;kBA3EkB3B,mB","file":"per_operation_sampler.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport assert from 'assert';\nimport * as constants from '../constants.js';\nimport ProbabilisticSampler from './probabilistic_sampler.js';\nimport GuaranteedThroughputSampler from './guaranteed_throughput_sampler.js';\n\ntype SamplersByOperation = { [key: string]: GuaranteedThroughputSampler, __proto__: null };\n\n// PerOperationSampler keeps track of all operation names it is asked to sample\n// and uses GuaranteedThroughputSampler for each operation name to ensure\n// that all endpoints are represented in the sampled traces. If the number\n// of distinct operation names exceeds maxOperations, all other names are\n// sampled with a default probabilistic sampler.\nexport default class PerOperationSampler {\n  _maxOperations: number;\n  _samplersByOperation: SamplersByOperation;\n  _defaultSampler: ProbabilisticSampler;\n  _defaultLowerBound: number;\n\n  constructor(strategies: PerOperationSamplingStrategies, maxOperations: number) {\n    this._maxOperations = maxOperations;\n    this._samplersByOperation = Object.create(null);\n    this.update(strategies);\n  }\n\n  update(strategies: PerOperationSamplingStrategies): boolean {\n    assert(\n      typeof strategies.defaultLowerBoundTracesPerSecond === 'number',\n      'expected strategies.defaultLowerBoundTracesPerSecond to be number'\n    );\n    assert(\n      typeof strategies.defaultSamplingProbability === 'number',\n      'expected strategies.defaultSamplingProbability to be number'\n    );\n\n    let updated: boolean = this._defaultLowerBound !== strategies.defaultLowerBoundTracesPerSecond;\n    this._defaultLowerBound = strategies.defaultLowerBoundTracesPerSecond;\n    strategies.perOperationStrategies.forEach(strategy => {\n      let operation = strategy.operation;\n      let samplingRate = strategy.probabilisticSampling.samplingRate;\n      let sampler = this._samplersByOperation[operation];\n      if (sampler) {\n        if (sampler.update(this._defaultLowerBound, samplingRate)) {\n          updated = true;\n        }\n      } else {\n        sampler = new GuaranteedThroughputSampler(this._defaultLowerBound, samplingRate);\n        this._samplersByOperation[operation] = sampler;\n        updated = true;\n      }\n    });\n    let defaultSamplingRate = strategies.defaultSamplingProbability;\n    if (!this._defaultSampler || this._defaultSampler.samplingRate != defaultSamplingRate) {\n      this._defaultSampler = new ProbabilisticSampler(defaultSamplingRate);\n      updated = true;\n    }\n    return updated;\n  }\n\n  name(): string {\n    return 'PerOperationSampler';\n  }\n\n  toString(): string {\n    return `${this.name()}(maxOperations=${this._maxOperations})`;\n  }\n\n  isSampled(operation: string, tags: any): boolean {\n    let sampler: Sampler = this._samplersByOperation[operation];\n    if (!sampler) {\n      if (Object.keys(this._samplersByOperation).length >= this._maxOperations) {\n        return this._defaultSampler.isSampled(operation, tags);\n      }\n      sampler = new GuaranteedThroughputSampler(this._defaultLowerBound, this._defaultSampler.samplingRate);\n      this._samplersByOperation[operation] = sampler;\n    }\n    return sampler.isSampled(operation, tags);\n  }\n\n  equal(other: Sampler): boolean {\n    return false; // TODO equal should be removed\n  }\n\n  close(callback: ?Function): void {\n    // all nested samplers are of simple types, so we do not need to Close them\n    if (callback) {\n      callback();\n    }\n  }\n}\n"]}