{"version":3,"sources":["../../src/span.js"],"names":["constants","opentracing","Span","tracer","operationName","spanContext","startTime","references","_tracer","_operationName","_spanContext","_startTime","_logger","_references","_baggageSetter","_logs","_tags","key","baggageHeaderCache","_getBaggageHeaderCache","normalizedKey","replace","toLowerCase","Object","keys","length","value","_normalizeBaggageKey","setBaggage","baggage","samplingFinalized","isSampled","sampler","_sampler","tags","flags","SAMPLED_MASK","addTags","finalizeSampling","finishTime","_duration","undefined","spanInfo","context","toString","error","endTime","now","_report","keyValuePairs","samplingKey","Tags","SAMPLING_PRIORITY","samplingPriority","samplingPriorityWasSet","_setSamplingPriority","_isWriteable","hasOwnProperty","push","timestamp","fields","convertObjectToTags","eventName","payload","log","event","priority","isDebug","_isDebugAllowed","DEBUG_MASK","_serviceName","_baggageHeaderCache"],"mappings":"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","file":"span.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport * as constants from './constants.js';\nimport SpanContext from './span_context.js';\nimport * as opentracing from 'opentracing';\nimport Utils from './util.js';\nimport BaggageSetter from './baggage/baggage_setter';\n\nexport default class Span {\n  _tracer: any;\n  _operationName: string;\n  _spanContext: SpanContext;\n  _startTime: number;\n  _logger: any;\n  _duration: number;\n  _logs: Array<LogData>;\n  _tags: Array<Tag>;\n  static _baggageHeaderCache: any;\n  _references: Array<Reference>;\n  _baggageSetter: BaggageSetter;\n\n  constructor(\n    tracer: any,\n    operationName: string,\n    spanContext: SpanContext,\n    startTime: number,\n    references: Array<Reference>\n  ) {\n    this._tracer = tracer;\n    this._operationName = operationName;\n    this._spanContext = spanContext;\n    this._startTime = startTime;\n    this._logger = tracer._logger;\n    this._references = references;\n    this._baggageSetter = tracer._baggageSetter;\n    this._logs = [];\n    this._tags = [];\n  }\n\n  get operationName(): string {\n    return this._operationName;\n  }\n\n  get serviceName(): string {\n    return this._tracer._serviceName;\n  }\n\n  static _getBaggageHeaderCache() {\n    if (!Span._baggageHeaderCache) {\n      Span._baggageHeaderCache = {};\n    }\n\n    return Span._baggageHeaderCache;\n  }\n\n  /**\n   * Returns a normalize key.\n   *\n   * @param {string} key - The key to be normalized for a particular baggage value.\n   * @return {string} - The normalized key (lower cased and underscores replaced, along with dashes.)\n   **/\n  _normalizeBaggageKey(key: string) {\n    let baggageHeaderCache = Span._getBaggageHeaderCache();\n    if (key in baggageHeaderCache) {\n      return baggageHeaderCache[key];\n    }\n\n    let normalizedKey: string = key.replace(/_/g, '-').toLowerCase();\n\n    if (Object.keys(baggageHeaderCache).length < 100) {\n      baggageHeaderCache[key] = normalizedKey;\n    }\n\n    return normalizedKey;\n  }\n\n  /**\n   * Sets a baggage value with an associated key.\n   *\n   * @param {string} key - The baggage key.\n   * @param {string} value - The baggage value.\n   *\n   * @return {Span} - returns this span.\n   **/\n  setBaggageItem(key: string, value: string): Span {\n    let normalizedKey = this._normalizeBaggageKey(key);\n\n    // We create a new instance of the context here instead of just adding\n    // another entry to the baggage dictionary. By doing so we keep the\n    // baggage immutable so that it can be passed to children spans as is.\n    // If it was mutable, we would have to make a copy of the dictionary\n    // for every child span, which on average we expect to occur more\n    // frequently than items being added to the baggage.\n    this._spanContext = this._baggageSetter.setBaggage(this, normalizedKey, value);\n    return this;\n  }\n\n  /**\n   * Gets a baggage value with an associated key.\n   *\n   * @param {string} key - The baggage key.\n   * @return {string} value - The baggage value.\n   **/\n  getBaggageItem(key: string): string {\n    let normalizedKey = this._normalizeBaggageKey(key);\n    return this._spanContext.baggage[normalizedKey];\n  }\n\n  /**\n   * Returns the span context that represents this span.\n   *\n   * @return {SpanContext} - Returns this span's span context.\n   **/\n  context(): SpanContext {\n    return this._spanContext;\n  }\n\n  /**\n   *  Returns the tracer associated with this span.\n   *\n   * @return {Tracer} - returns the tracer associated with this span.\n   **/\n  tracer(): any {\n    return this._tracer;\n  }\n\n  /**\n   * Checks whether or not a span can be written to.\n   *\n   * @return {boolean} - The decision about whether this span can be written to.\n   **/\n  _isWriteable(): boolean {\n    return !this._spanContext.samplingFinalized || this._spanContext.isSampled();\n  }\n\n  /**\n   * Sets the operation name on this given span.\n   *\n   * @param {string} name - The name to use for setting a span's operation name.\n   * @return {Span} - returns this span.\n   **/\n  setOperationName(operationName: string): Span {\n    this._operationName = operationName;\n    // We re-sample the span if it has not been finalized.\n    if (this._spanContext.samplingFinalized) {\n      return this;\n    }\n\n    let sampler = this.tracer()._sampler;\n    let tags = {};\n    if (sampler.isSampled(operationName, tags)) {\n      this._spanContext.flags |= constants.SAMPLED_MASK;\n      this.addTags(tags);\n    }\n    this._spanContext.finalizeSampling();\n\n    return this;\n  }\n\n  /**\n   * Sets the end timestamp and finalizes Span state.\n   *\n   * With the exception of calls to Span.context() (which are always allowed),\n   * finish() must be the last call made to any span instance, and to do\n   * otherwise leads to undefined behavior.\n   *\n   * @param  {number} finishTime\n   *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n   *         values are supported for timestamps with sub-millisecond accuracy.\n   *         If not specified, the current time (as defined by the\n   *         implementation) will be used.\n   */\n  finish(finishTime: ?number): void {\n    if (this._duration !== undefined) {\n      let spanInfo = `operation=${this.operationName},context=${this.context().toString()}`;\n      this.tracer()._logger.error(`${spanInfo}#You can only call finish() on a span once.`);\n      return;\n    }\n\n    this._spanContext.finalizeSampling();\n    if (this._spanContext.isSampled()) {\n      let endTime = finishTime || this._tracer.now();\n      this._duration = endTime - this._startTime;\n      this._tracer._report(this);\n    }\n  }\n\n  /**\n   * Adds a set of tags to a span.\n   *\n   * @param {Object} keyValuePairs - An object with key value pairs\n   * that represent tags to be added to this span.\n   * @return {Span} - returns this span.\n   **/\n  addTags(keyValuePairs: any): Span {\n    const samplingKey = opentracing.Tags.SAMPLING_PRIORITY;\n    const samplingPriority = keyValuePairs[samplingKey];\n    const samplingPriorityWasSet = samplingPriority != null && this._setSamplingPriority(samplingPriority);\n    if (this._isWriteable()) {\n      for (let key in keyValuePairs) {\n        if (keyValuePairs.hasOwnProperty(key)) {\n          if (key === samplingKey && !samplingPriorityWasSet) {\n            continue;\n          }\n          const value = keyValuePairs[key];\n          this._tags.push({ key: key, value: value });\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Adds a single tag to a span\n   *\n   * @param {string} key - The key for the tag added to this span.\n   * @param {string} value - The value corresponding with the key\n   * for the tag added to this span.\n   * @return {Span} - returns this span.\n   * */\n  setTag(key: string, value: any): Span {\n    if (key === opentracing.Tags.SAMPLING_PRIORITY && !this._setSamplingPriority(value)) {\n      return this;\n    }\n\n    if (this._isWriteable()) {\n      this._tags.push({ key: key, value: value });\n    }\n    return this;\n  }\n\n  /**\n   * Adds a log event, or payload to a span.\n   *\n   * @param {object} keyValuePairs\n   *        An object mapping string keys to arbitrary value types. All\n   *        Tracer implementations should support bool, string, and numeric\n   *        value types, and some may also support Object values.\n   * @param {number} timestamp\n   *        An optional parameter specifying the timestamp in milliseconds\n   *        since the Unix epoch. Fractional values are allowed so that\n   *        timestamps with sub-millisecond accuracy can be represented. If\n   *        not specified, the implementation is expected to use its notion\n   *        of the current time of the call.\n   */\n  log(keyValuePairs: any, timestamp: ?number): void {\n    if (this._isWriteable()) {\n      this._logs.push({\n        timestamp: timestamp || this._tracer.now(),\n        fields: Utils.convertObjectToTags(keyValuePairs),\n      });\n    }\n  }\n\n  /**\n   * Logs a event with an optional payload.\n   *\n   * @param  {string} eventName - string associated with the log record\n   * @param  {object} [payload] - arbitrary payload object associated with the\n   *         log record.\n   */\n  logEvent(eventName: string, payload: any): void {\n    return this.log({\n      event: eventName,\n      payload: payload,\n    });\n  }\n\n  /**\n   * Returns true if the flag was updated successfully, false otherwise\n   *\n   * @param priority - 0 to disable sampling, 1 to enable\n   * @returns {boolean} - true if the flag was updated successfully\n   * @private\n   */\n  _setSamplingPriority(priority: number): boolean {\n    this._spanContext.finalizeSampling();\n    if (priority > 0) {\n      if (this._spanContext.isDebug()) {\n        // If the span is already in debug, no need to set it again\n        return false;\n      }\n      if (this._tracer._isDebugAllowed(this._operationName)) {\n        this._spanContext.flags = this._spanContext.flags | constants.SAMPLED_MASK | constants.DEBUG_MASK;\n        return true;\n      }\n      return false;\n    }\n    this._spanContext.flags = this._spanContext.flags & ~constants.SAMPLED_MASK;\n    return true;\n  }\n}\n"]}