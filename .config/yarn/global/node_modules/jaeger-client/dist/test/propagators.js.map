{"version":3,"sources":["../../test/propagators.js"],"names":["constants","describe","it","codec","urlEncoding","_decodeURIValue","value","URIError","strictEqual","_decodeValue","contextKey","ctx","fromString","out","inject","baggagePrefix","carrier","extract","deepEqual","baggage","foo","equal","parentIdStr","spanIdStr","traceIdStr","isSampled","isDebug","isNotOk","withStringIds","flags","DEBUG_MASK","SAMPLED_MASK","isUndefined","withBaggageItem"],"mappings":"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","file":"propagators.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport { assert } from 'chai';\nimport * as constants from '../src/constants';\nimport TextMapCodec from '../src/propagators/text_map_codec';\nimport ZipkinB3TextMapCodec from '../src/propagators/zipkin_b3_text_map_codec';\nimport SpanContext from '../src/span_context';\n\ndescribe('TextMapCodec', () => {\n  it('should not URL-decode value that has no % meta-characters', () => {\n    let codec = new TextMapCodec({ urlEncoding: true });\n    codec._decodeURIValue = (value: string) => {\n      throw new URIError('fake error');\n    };\n    assert.strictEqual(codec._decodeValue('abc'), 'abc');\n  });\n\n  it('should not throw exception on bad URL-encoded values', () => {\n    let codec = new TextMapCodec({ urlEncoding: true });\n    // this string throws exception when passed to decodeURIComponent\n    assert.strictEqual(codec._decodeValue('%EA'), '%EA');\n  });\n\n  it('should not URL-encode span context', () => {\n    let codec = new TextMapCodec({ urlEncoding: true, contextKey: 'trace-context' });\n    let ctx = SpanContext.fromString('1:1:1:1');\n    let out = {};\n    codec.inject(ctx, out);\n    assert.strictEqual(out['trace-context'], '1:1:1:1');\n  });\n\n  it('should decode baggage', () => {\n    let codec = new TextMapCodec({\n      urlEncoding: true,\n      contextKey: 'trace-context',\n      baggagePrefix: 'baggage-',\n    });\n    let carrier = {\n      'trace-context': '1:1:1:1',\n      'baggage-some-key': 'some-value',\n      'garbage-in': 'garbage-out',\n    };\n    let ctx = codec.extract(carrier);\n    assert.deepEqual(ctx.baggage, { 'some-key': 'some-value' });\n  });\n});\n\ndescribe('ZipkinB3TextMapCodec', () => {\n  it('correctly extract the zipkin headers from a span context', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n\n    let carrier = {\n      'x-b3-parentspanid': '123abc',\n      'x-b3-spanid': 'aaafff',\n      'x-b3-traceid': '789fed',\n      'x-b3-sampled': '1',\n      'x-b3-flags': '1',\n      foo: 'bar',\n    };\n\n    let ctx = codec.extract(carrier);\n    assert.equal(ctx.parentIdStr, '123abc');\n    assert.equal(ctx.spanIdStr, 'aaafff');\n    assert.equal(ctx.traceIdStr, '789fed');\n    assert.equal(ctx.isSampled(), true);\n    assert.equal(ctx.isDebug(), true);\n  });\n\n  it('use an empty context if the zipkin headers contain invalid ids', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n\n    let carrier = {\n      'x-b3-parentspanid': 'bad-value',\n      'x-b3-spanid': 'another-bad-value',\n      'x-b3-traceid': 'not-a-valid-traceid',\n      'x-b3-sampled': '1',\n      'x-b3-flags': '1',\n      foo: 'bar',\n    };\n\n    let ctx = codec.extract(carrier);\n    assert.isNotOk(ctx.parentIdStr);\n    assert.isNotOk(ctx.spanIdStr);\n    assert.isNotOk(ctx.traceIdStr);\n    assert.equal(ctx.isSampled(), true);\n    assert.equal(ctx.isDebug(), true);\n  });\n  it('correctly inject the zipkin headers into a span context', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n    let carrier = {};\n\n    let ctx = SpanContext.withStringIds('789fed', 'aaafff', '123abc');\n    ctx.flags = constants.DEBUG_MASK | constants.SAMPLED_MASK;\n\n    codec.inject(ctx, carrier);\n    assert.equal(carrier['x-b3-traceid'], '789fed');\n    assert.equal(carrier['x-b3-spanid'], 'aaafff');\n    assert.equal(carrier['x-b3-parentspanid'], '123abc');\n    assert.equal(carrier['x-b3-flags'], '1');\n\n    // > Since Debug implies Sampled, so don't also send \"X-B3-Sampled: 1\"\n    // https://github.com/openzipkin/b3-propagation\n    assert.isUndefined(carrier['x-b3-sampled']);\n  });\n\n  it('should not URL-decode value that has no % meta-characters', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n    codec._decodeURIValue = (value: string) => {\n      throw new URIError('fake error');\n    };\n    assert.strictEqual(codec._decodeValue('abc'), 'abc');\n  });\n\n  it('should not throw exception on bad URL-encoded values', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n    // this string throws exception when passed to decodeURIComponent\n    assert.strictEqual(codec._decodeValue('%EA'), '%EA');\n  });\n\n  it('should decode baggage', () => {\n    let codec = new ZipkinB3TextMapCodec({\n      urlEncoding: true,\n      contextKey: 'trace-context',\n      baggagePrefix: 'baggage-',\n    });\n    let carrier = {\n      'x-b3-parentspanid': '123abc',\n      'x-b3-spanid': 'aaafff',\n      'x-b3-traceid': '789fed',\n      'baggage-some-key': 'some-value',\n      'garbage-in': 'garbage-out',\n    };\n    let ctx = codec.extract(carrier);\n    assert.deepEqual(ctx.baggage, { 'some-key': 'some-value' });\n  });\n\n  it('should encode baggage', () => {\n    let codec = new ZipkinB3TextMapCodec({\n      urlEncoding: true,\n      contextKey: 'trace-context',\n      baggagePrefix: 'baggage-',\n    });\n    let carrier = {};\n\n    let ctx = SpanContext.withStringIds('789fed', 'aaafff', '123abc');\n    ctx = ctx.withBaggageItem('some-key', 'some-value');\n    ctx = ctx.withBaggageItem('another-key', 'another-value');\n\n    codec.inject(ctx, carrier);\n    assert.equal(carrier['baggage-some-key'], 'some-value');\n    assert.equal(carrier['baggage-another-key'], 'another-value');\n  });\n});\n"]}