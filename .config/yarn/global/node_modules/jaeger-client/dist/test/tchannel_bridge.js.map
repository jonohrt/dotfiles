{"version":3,"sources":["../../test/tchannel_bridge.js"],"names":["constants","describe","BIG_TIMEOUT","reporter","tracer","bridge","contextFactory","originalSpan","startSpan","setBaggageItem","ctx1","setSpan","options","as","mode","context","headers","each","o","description","channelEncoding","it","server","serviceName","timeout","trace","forceTrace","listen","onServerListening","client","clientSubChannel","makeSubChannel","peers","encodedChannel","channel","entryPoint","join","__dirname","register","tracedHandler","handleServerReq","req","head","body","callback","equal","Object","keys","length","traceIdStr","getSpan","ok","value","err","res","arg2","arg3","tracedChannel","clientCallback","isNotOk","spans","serverSpan","clientSpan","serverSpanTags","Tags","PEER_SERVICE","SPAN_KIND","SPAN_KIND_RPC_SERVER","clientSpanTags","SPAN_KIND_RPC_CLIENT","isOk","hasTags","parentIdStr","spanIdStr","clear","close","done","request","cn","send"],"mappings":"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","file":"tchannel_bridge.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport _ from 'lodash';\nimport { assert } from 'chai';\nimport * as constants from '../src/constants';\nimport ConstSampler from '../src/samplers/const_sampler';\nimport DefaultContext from '../src/default_context';\nimport path from 'path';\nimport InMemoryReporter from '../src/reporters/in_memory_reporter';\nimport opentracing from 'opentracing';\nimport TestUtils from '../src/test_util.js';\nimport Tracer from '../src/tracer';\nimport TChannel from 'tchannel';\nimport TChannelBridge from '../src/tchannel_bridge.js';\nimport TChannelAsThrift from 'tchannel/as/thrift';\nimport TChannelAsJSON from 'tchannel/as/json';\nimport combinations from './lib/combinations.js';\n\ndescribe('test tchannel span bridge', () => {\n  // BIG_TIMEOUT is useful for debugging purposes.\n  let BIG_TIMEOUT = 15000000;\n  let reporter = new InMemoryReporter();\n  let tracer = new Tracer('test-service', reporter, new ConstSampler(true));\n  let bridge = new TChannelBridge(tracer, {\n    contextFactory: () => {\n      return new DefaultContext();\n    },\n  });\n  let originalSpan = tracer.startSpan('futurama');\n  originalSpan.setBaggageItem('leela', 'fry');\n  let ctx1 = new DefaultContext();\n  ctx1.setSpan(originalSpan);\n\n  let options = combinations({\n    as: ['json', 'thrift'],\n    mode: ['req.send', 'channel.send'],\n    context: [ctx1, null],\n    headers: [{}, null],\n  });\n\n  _.each(options, o => {\n    o.description = `as=${o.as}|mode=${o.mode}`;\n    o.channelEncoding = o.as === 'json' ? TChannelAsJSON : TChannelAsThrift;\n\n    it(o.description + ' spans propagate through tchannel and preserve parent span properties', done => {\n      let server = new TChannel({\n        serviceName: 'server',\n        timeout: BIG_TIMEOUT,\n        // force tracing on in order to prove that overriding works\n        trace: true,\n        forceTrace: true,\n      });\n      // Server calls client channel after it starts listening.\n      server.listen(4040, '127.0.0.1', onServerListening);\n\n      // Create the top level client channel.\n      let client = new TChannel({\n        // force tracing on in order to prove that overriding works\n        trace: true,\n        forceTrace: true,\n      });\n\n      // Create the client subchannel that makes requests.\n      let clientSubChannel = client.makeSubChannel({\n        serviceName: 'server',\n        peers: ['127.0.0.1:4040'],\n      });\n\n      // Wrap the subchannel in an encoding\n      let encodedChannel = o.channelEncoding({\n        channel: clientSubChannel,\n        entryPoint: path.join(__dirname, 'thrift', 'echo.thrift'), // ignored in json case\n      });\n\n      let options: any = {};\n      encodedChannel.register(server, 'Echo::echo', options, bridge.tracedHandler(handleServerReq));\n      function handleServerReq(context, req, head, body, callback) {\n        // headers should not contain $tracing$ prefixed keys, which should be the\n        // only headers used for this test.\n        assert.equal(Object.keys(head).length, 0);\n\n        // assert that the serverSpan is a child of the original span, if context exists\n        // assert that the serverSpan is NOT a child of the original span, if contexts is null\n        assert.equal(\n          originalSpan.context().traceIdStr === req.context.getSpan().context().traceIdStr,\n          !!o.context\n        );\n        callback(null, { ok: true, body: { value: 'some-string' } });\n      }\n\n      function onServerListening(err, res, arg2, arg3) {\n        // Outgoing tchannel call is traced\n        let tracedChannel = bridge.tracedChannel(encodedChannel);\n\n        let clientCallback = (err, res, headers, body) => {\n          assert.isNotOk(err);\n          assert.equal(reporter.spans.length, 2);\n\n          // the first span to be reported is the server span\n          let serverSpan = reporter.spans[0];\n          // the second span to be reported is the client span\n          let clientSpan = reporter.spans[1];\n\n          let serverSpanTags = {};\n          serverSpanTags[opentracing.Tags.PEER_SERVICE] = 'echo';\n          serverSpanTags[opentracing.Tags.SPAN_KIND] = opentracing.Tags.SPAN_KIND_RPC_SERVER;\n          serverSpanTags['as'] = o.as;\n          // TODO(oibe) the port for the client request ephemeral, and I don't know how to get it, or if I can.\n\n          let clientSpanTags = {};\n          clientSpanTags[opentracing.Tags.PEER_SERVICE] = 'server';\n          clientSpanTags[opentracing.Tags.SPAN_KIND] = opentracing.Tags.SPAN_KIND_RPC_CLIENT;\n\n          assert.isOk(TestUtils.hasTags(serverSpan, serverSpanTags));\n          assert.isOk(TestUtils.hasTags(clientSpan, clientSpanTags));\n\n          assert.equal(serverSpan.context().parentIdStr, clientSpan.context().spanIdStr);\n          // If context exists then the following conditions are true\n          // else the following conditons are false\n          assert.equal(serverSpan.context().traceIdStr === originalSpan.context().traceIdStr, !!o.context);\n          assert.equal(clientSpan.context().traceIdStr === originalSpan.context().traceIdStr, !!o.context);\n\n          reporter.clear();\n          server.close();\n          client.close();\n          done();\n        };\n\n        if (o.mode === 'req.send') {\n          let req = tracedChannel.request({\n            serviceName: 'server',\n            headers: { cn: 'echo' },\n            context: o.context,\n            timeout: BIG_TIMEOUT,\n          });\n          req.send('Echo::echo', o.headers, { value: 'some-string' }, clientCallback);\n        } else if (o.mode === 'channel.send') {\n          let req = tracedChannel.channel.request({\n            serviceName: 'server',\n            headers: { cn: 'echo' },\n            context: o.context,\n            timeout: BIG_TIMEOUT,\n          });\n          tracedChannel.send(req, 'Echo::echo', o.headers, { value: 'some-string' }, clientCallback);\n        }\n      }\n    }).timeout(BIG_TIMEOUT);\n  });\n});\n"]}