'use strict';

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _chai = require('chai');

var _const_sampler = require('../src/samplers/const_sampler.js');

var _const_sampler2 = _interopRequireDefault(_const_sampler);

var _constants = require('../src/constants.js');

var constants = _interopRequireWildcard(_constants);

var _in_memory_reporter = require('../src/reporters/in_memory_reporter.js');

var _in_memory_reporter2 = _interopRequireDefault(_in_memory_reporter);

var _opentracing = require('opentracing');

var opentracing = _interopRequireWildcard(_opentracing);

var _span_context = require('../src/span_context.js');

var _span_context2 = _interopRequireDefault(_span_context);

var _tracer = require('../src/tracer.js');

var _tracer2 = _interopRequireDefault(_tracer);

var _util = require('../src/util.js');

var _util2 = _interopRequireDefault(_util);

var _metrics = require('../src/metrics/metrics.js');

var _metrics2 = _interopRequireDefault(_metrics);

var _metric_factory = require('./lib/metrics/local/metric_factory.js');

var _metric_factory2 = _interopRequireDefault(_metric_factory);

var _backend = require('./lib/metrics/local/backend.js');

var _backend2 = _interopRequireDefault(_backend);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _default_throttler = require('../src/throttler/default_throttler');

var _default_throttler2 = _interopRequireDefault(_default_throttler);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2016 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
// in compliance with the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
// or implied. See the License for the specific language governing permissions and limitations under
// the License.

describe('tracer should', function () {
  var tracer = void 0;
  var reporter = new _in_memory_reporter2.default();

  beforeEach(function () {
    tracer = new _tracer2.default('test-service-name', reporter, new _const_sampler2.default(true));
  });

  afterEach(function () {
    reporter.clear();
    tracer.close();
  });

  it('be able to override codec contextKey and extract context', function () {
    var ck = 'test-trace-id';
    var mytracer = new _tracer2.default('test-service-name', reporter, new _const_sampler2.default(true), {
      contextKey: ck
    });

    var headers = {
      'test-trace-id': 'a:b:c:d'
    };

    var mycontext = mytracer.extract(opentracing.FORMAT_HTTP_HEADERS, headers);
    _chai.assert.equal(mycontext.toString(), headers[ck]);

    var myspan = mytracer.startSpan('myspan', { childOf: mycontext });
    _chai.assert.equal(myspan.context().traceIdStr, 'a');

    var exheaders = {};

    mytracer.inject(myspan.context(), opentracing.FORMAT_HTTP_HEADERS, exheaders);
    _chai.assert.notEqual(exheaders[ck], null);
  });

  it('begin a new span given only baggage headers', function () {
    // Users sometimes want to pass baggage even if there is no span.
    // In this case we must ensure a new root span is created.
    var headers = {};
    // combine normal baggage encoding
    headers[constants.TRACER_BAGGAGE_HEADER_PREFIX + 'robot'] = 'Bender';
    // with custom encoding via `jaeger-baggage` header
    headers[constants.JAEGER_BAGGAGE_HEADER] = 'male=Fry, female=Leela, Lord Nibbler';
    var spanContext = tracer.extract(opentracing.FORMAT_TEXT_MAP, headers);
    var rootSpan = tracer.startSpan('fry', { childOf: spanContext });

    _chai.assert.isOk(rootSpan.context().traceId);
    _chai.assert.isNotOk(rootSpan.context().parentId);
    _chai.assert.equal(rootSpan.context().flags, 1);
    _chai.assert.equal('Bender', rootSpan.getBaggageItem('robot'));
    _chai.assert.equal('Leela', rootSpan.getBaggageItem('female'));
    _chai.assert.equal('Fry', rootSpan.getBaggageItem('male'));
  });

  it('create a span correctly through _startInternalSpan', function () {
    var traceId = _util2.default.encodeInt64(1);
    var spanId = _util2.default.encodeInt64(2);
    var parentId = _util2.default.encodeInt64(3);
    var flags = 1;
    var context = _span_context2.default.withBinaryIds(traceId, spanId, parentId, flags);
    var start = 123.456;
    var rpcServer = false;
    var internalTags = [];
    var references = [];
    var tags = {
      keyOne: 'leela',
      keyTwo: 'bender'
    };
    var span = tracer._startInternalSpan(context, 'op-name', start, internalTags, tags, null, rpcServer, references);

    _chai.assert.deepEqual(span.context().traceId, traceId);
    _chai.assert.deepEqual(span.context().spanId, spanId);
    _chai.assert.deepEqual(span.context().parentId, parentId);
    _chai.assert.equal(span.context().flags, flags);
    _chai.assert.equal(span._startTime, start);
    _chai.assert.equal(Object.keys(span._tags).length, 2);
  });

  it('report a span with no tracer level tags', function () {
    var span = tracer.startSpan('op-name');
    tracer._report(span);
    _chai.assert.isOk(reporter.spans.length, 1);
    var actualTags = _lodash2.default.sortBy(span._tags, function (o) {
      return o.key;
    });

    _chai.assert.equal(2, actualTags.length);
    _chai.assert.equal(actualTags[0].key, 'sampler.param');
    _chai.assert.equal(actualTags[1].key, 'sampler.type');
    _chai.assert.equal(actualTags[0].value, true);
    _chai.assert.equal(actualTags[1].value, 'const');
  });

  it('start a root span with proper structure', function () {
    var startTime = new Date(2016, 8, 18).getTime();
    var span = tracer.startSpan('test-name', {
      startTime: startTime
    });

    _chai.assert.equal(span.context().traceId, span.context().spanId);
    _chai.assert.isNotOk(span.context().parentId);
    _chai.assert.isOk(span.context().isSampled());
    _chai.assert.equal(span._startTime, startTime);
  });

  describe('start a child span represented as a separate span from parent, using childOf and references', function () {
    var nextId = 0;
    var getId = function getId() {
      return _util2.default.encodeInt64(nextId++);
    };
    var traceId = getId();
    var flags = 1;

    var parentContext = _span_context2.default.withBinaryIds(traceId, getId(), null, flags);
    var childOfContext = _span_context2.default.withBinaryIds(traceId, getId(), null, flags);
    var childOfRef = new opentracing.Reference(opentracing.REFERENCE_CHILD_OF, childOfContext);
    var followsFromContext = _span_context2.default.withBinaryIds(traceId, getId(), null, flags);
    var followsFromRef = new opentracing.Reference(opentracing.REFERENCE_FOLLOWS_FROM, followsFromContext);

    var testCases = [{
      message: 'starts a span based on childOf',
      spanOptions: {
        childOf: parentContext,
        references: []
      },
      verify: parentContext
    }, {
      message: 'starts a span based on childOf, ignoring FOLLOWS_FROM',
      spanOptions: {
        childOf: parentContext,
        references: [followsFromRef]
      },
      verify: parentContext
    }, {
      message: 'starts a span based on childOf, ignoring CHILD_OF and FOLLOWS_FROM',
      spanOptions: {
        childOf: parentContext,
        references: [childOfRef, followsFromRef]
      },
      verify: parentContext
    }, {
      message: 'starts a span with parent falling back to the CHILD_OF ref',
      spanOptions: {
        childOf: null,
        references: [childOfRef]
      },
      verify: childOfContext
    }, {
      message: 'starts a span with parent falling back to the FOLLOWS_FROM ref',
      spanOptions: {
        childOf: null,
        references: [followsFromRef]
      },
      verify: followsFromContext
    }, {
      message: 'starts a span with parent falling back to the CHILD_OF ref and ignoring FOLLOWS_FROM',
      spanOptions: {
        childOf: null,
        references: [childOfRef, followsFromRef]
      },
      verify: childOfContext
    }];

    testCases.forEach(function (params) {
      var message = params.message,
          spanOptions = params.spanOptions,
          verify = params.verify;

      it(message, function () {
        var span = tracer.startSpan('bender', {
          childOf: spanOptions.childOf,
          references: spanOptions.references
        });
        span.finish();
        _chai.assert.deepEqual(span.context().traceId, verify.traceId);
        _chai.assert.deepEqual(span.context().parentId, verify.spanId);
      });
    });
  });

  it('inject plain text headers into carrier, and extract span context with the same value', function () {
    var keyOne = 'keyOne';
    var keyTwo = 'keyTwo';
    var baggage = {
      keyOne: 'leela',
      keyTwo: 'bender'
    };
    var savedContext = _span_context2.default.withBinaryIds(_util2.default.encodeInt64(1), _util2.default.encodeInt64(2), _util2.default.encodeInt64(3), constants.SAMPLED_MASK, baggage);

    var assertByFormat = function assertByFormat(format) {
      var carrier = {};
      tracer.inject(savedContext, format, carrier);
      var extractedContext = tracer.extract(format, carrier);

      _chai.assert.deepEqual(savedContext.traceId, extractedContext.traceId);
      _chai.assert.deepEqual(savedContext.spanId, extractedContext.spanId);
      _chai.assert.deepEqual(savedContext.parentId, extractedContext.parentId);
      _chai.assert.equal(savedContext.flags, extractedContext.flags);
      _chai.assert.equal(savedContext.baggage[keyOne], extractedContext.baggage[keyOne]);
      _chai.assert.equal(savedContext.baggage[keyTwo], extractedContext.baggage[keyTwo]);
    };

    assertByFormat(opentracing.FORMAT_TEXT_MAP);
    assertByFormat(opentracing.FORMAT_HTTP_HEADERS);
  });

  it('inject url encoded values into headers', function () {
    var baggage = {
      keyOne: 'Leela vs. Bender'
    };
    var savedContext = _span_context2.default.withBinaryIds(_util2.default.encodeInt64(1), _util2.default.encodeInt64(2), _util2.default.encodeInt64(3), constants.SAMPLED_MASK, baggage);
    var carrier = {};

    tracer.inject(savedContext, opentracing.FORMAT_HTTP_HEADERS, carrier);
    _chai.assert.equal(carrier['uberctx-keyOne'], 'Leela%20vs.%20Bender');
  });

  it('assert inject and extract throw errors when given an invalid format', function () {
    var carrier = {};
    var context = _span_context2.default.withBinaryIds(_util2.default.encodeInt64(1), _util2.default.encodeInt64(2), _util2.default.encodeInt64(3), constants.SAMPLED_MASK);

    // subtle but expect wants a function to call not the result of a function call.
    (0, _chai.expect)(function () {
      tracer.inject(context, 'fake-format', carrier);
    }).to.throw('Unsupported format: fake-format');
    (0, _chai.expect)(function () {
      tracer.extract('fake-format', carrier);
    }).to.throw('Unsupported format: fake-format');
  });

  it('report spans', function () {
    var span = tracer.startSpan('operation');
    tracer._report(span);

    _chai.assert.equal(reporter.spans.length, 1);
  });

  it('set _process on initialization', function () {
    var throttler = new _default_throttler2.default();
    throttler.setProcess = _sinon2.default.spy();
    tracer = new _tracer2.default('x', reporter, new _const_sampler2.default(true), {
      debugThrottler: throttler
    });
    _chai.assert.equal(tracer._process.serviceName, 'x');
    _chai.assert.isString(tracer._process.uuid);
    _sinon2.default.assert.calledWith(throttler.setProcess, tracer._process);
  });

  it('close _debugThrottler on close', function () {
    var throttler = new _default_throttler2.default();
    throttler.close = _sinon2.default.spy();
    tracer = new _tracer2.default('x', reporter, new _const_sampler2.default(true), {
      debugThrottler: throttler
    });
    tracer.close();
    _sinon2.default.assert.calledOnce(throttler.close);
  });

  describe('Metrics', function () {
    it('startSpan', function () {
      var params = [{
        rpcServer: false,
        context: null,
        sampled: true,
        metrics: ['spansStartedSampled', 'tracesStartedSampled']
      }, {
        rpcServer: true,
        context: '1:2:100:1',
        sampled: true,
        metrics: ['spansStartedSampled', 'tracesJoinedSampled']
      }, {
        rpcServer: false,
        context: null,
        sampled: false,
        metrics: ['spansStartedNotSampled', 'tracesStartedNotSampled']
      }, {
        rpcServer: true,
        context: '1:2:100:0',
        sampled: false,
        metrics: ['spansStartedNotSampled', 'tracesJoinedNotSampled']
      }];

      _lodash2.default.each(params, function (o) {
        var metrics = new _metrics2.default(new _metric_factory2.default());
        tracer = new _tracer2.default('fry', new _in_memory_reporter2.default(), new _const_sampler2.default(o.sampled), {
          metrics: metrics
        });

        var context = null;
        if (o.context) {
          context = _span_context2.default.fromString(o.context);
        }

        var tags = {};
        if (o.rpcServer) {
          tags[opentracing.Tags.SPAN_KIND] = opentracing.Tags.SPAN_KIND_RPC_SERVER;
        }

        tracer.startSpan('bender', {
          childOf: context,
          tags: tags
        });

        _lodash2.default.each(o.metrics, function (metricName) {
          _chai.assert.isOk(_backend2.default.counterEquals(metrics[metricName], 1));
        });
      });
    });

    it('emits counter when report called', function () {
      var metrics = new _metrics2.default(new _metric_factory2.default());
      tracer = new _tracer2.default('fry', new _in_memory_reporter2.default(), new _const_sampler2.default(true), {
        metrics: metrics
      });
      var span = tracer.startSpan('bender');
      tracer._report(span);

      _chai.assert.isOk(_backend2.default.counterEquals(metrics.spansFinished, 1));
    });
  });
});
//# sourceMappingURL=tracer.js.map