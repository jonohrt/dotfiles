{"version":3,"sources":["../../../test/samplers/ratelimiting_sampler_test.js"],"names":["describe","it","initialDate","Date","getTime","clock","useFakeTimers","sampler","i","isTrue","isSampled","equal","maxTracesPerSecond","isNotOk","tags","decision","isFalse","deepEqual","restore","to","throw","otherSampler","isOk","update","limiter"],"mappings":"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","file":"ratelimiting_sampler_test.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport { assert, expect } from 'chai';\nimport ProbabilisticSampler from '../../src/samplers/probabilistic_sampler.js';\nimport RateLimitingSampler from '../../src/samplers/ratelimiting_sampler.js';\nimport sinon from 'sinon';\n\ndescribe('RateLimitingSampler should', () => {\n  it('block after threshold is met', () => {\n    let initialDate = new Date(2011, 9, 1).getTime();\n    let clock = sinon.useFakeTimers(initialDate);\n    let sampler = new RateLimitingSampler(10, 10);\n    for (let i = 0; i < 10; i++) {\n      assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n    }\n\n    assert.equal(sampler.maxTracesPerSecond, 10);\n    assert.isNotOk(sampler.equal(new ProbabilisticSampler(0.5)));\n\n    let tags = {};\n    let decision = sampler.isSampled('operation', tags);\n    assert.isFalse(decision, 'expected decision to be false');\n    assert.deepEqual(tags, {}, 'expected tags to be empty');\n\n    clock = sinon.useFakeTimers(initialDate + 1000);\n    tags = {};\n    decision = sampler.isSampled('operation', tags);\n    assert.isTrue(decision, 'expected decision to be true');\n    assert.deepEqual(tags, { 'sampler.type': 'ratelimiting', 'sampler.param': 10 });\n    clock.restore();\n  });\n\n  it('should throw error when initialized with an incorrect value', () => {\n    expect(() => {\n      new RateLimitingSampler(-2.0);\n    }).to.throw('maxTracesPerSecond must be greater than 0.0.  Received -2');\n  });\n\n  it('should equal another rate limiting sampler', () => {\n    let sampler = new RateLimitingSampler(1.0);\n    let otherSampler = new RateLimitingSampler(1.0);\n\n    assert.isOk(sampler.equal(otherSampler));\n  });\n\n  it('work with maxCreditsPerSecond smaller than 1', () => {\n    let initialDate = new Date(2011, 9, 1).getTime();\n    let clock = sinon.useFakeTimers(initialDate);\n    let sampler = new RateLimitingSampler(0.1, 1);\n\n    assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n\n    clock = sinon.useFakeTimers(initialDate + 10000);\n    assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n    clock.restore();\n  });\n\n  it('should update successfully', () => {\n    let initialDate = new Date(2011, 9, 1).getTime();\n    let clock = sinon.useFakeTimers(initialDate);\n    let sampler = new RateLimitingSampler(1.0, 1);\n\n    assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n\n    assert.isFalse(sampler.update(1.0), 'updating using the same maxTracesPerSecond should return false');\n    assert.isTrue(sampler.update(2.0), 'updating using a different maxTracesPerSecond should return true');\n\n    clock = sinon.useFakeTimers(initialDate + 20000);\n    let tags = {};\n    assert.isTrue(sampler.isSampled('operation', tags), 'expected decision to be true');\n    assert.deepEqual(tags, { 'sampler.type': 'ratelimiting', 'sampler.param': 2 });\n    assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n    assert.isFalse(sampler.isSampled('operation', {}), 'expected decision to be false');\n    clock.restore();\n  });\n\n  it('should throw error when updated with an incorrect value', () => {\n    let limiter = new RateLimitingSampler(2.0);\n    expect(() => {\n      limiter.update(-2.0);\n    }).to.throw('maxTracesPerSecond must be greater than 0.0.  Received -2');\n  });\n});\n"]}