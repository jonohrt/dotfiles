{"version":3,"sources":["../../../test/samplers/guaranteed_throughput_sampler.js"],"names":["describe","it","sampler","equal","name","callback","spy","close","calledOnce","isFalse","isOk","initialDate","Date","getTime","clock","useFakeTimers","expectedTags","forEach","actualTags","decision","isSampled","expectedDecision","deepEqual","isNotOk","restore","assertValues","lb","rate","_lowerBoundSampler","maxTracesPerSecond","_probabilisticSampler","samplingRate","p1","p2","isUpdated","update","strictEqual","isTrue","expectedTagsLB","expectedTagsProb","num","probability","sampled","tags","s","testCase"],"mappings":"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","file":"guaranteed_throughput_sampler.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport { assert } from 'chai';\nimport sinon from 'sinon';\nimport ConstSampler from '../../src/samplers/const_sampler';\nimport GuaranteedThroughputSampler from '../../src/samplers/guaranteed_throughput_sampler';\n\ndescribe('GuaranteedThroughput sampler', () => {\n  it('should have a name and be closable', () => {\n    let sampler = new GuaranteedThroughputSampler(2, 0);\n    assert.equal(sampler.name(), 'GuaranteedThroughputSampler');\n\n    let callback = sinon.spy();\n    sampler.close(callback);\n    assert(callback.calledOnce);\n  });\n\n  it('should not equal other types', () => {\n    let sampler = new GuaranteedThroughputSampler(2, 0);\n    assert.isFalse(sampler.equal(new ConstSampler(true)));\n    sampler.close();\n  });\n\n  it('should equal itself', () => {\n    let sampler = new GuaranteedThroughputSampler(2, 0);\n    assert.isOk(sampler.equal(sampler));\n    assert.isOk(sampler.equal(new GuaranteedThroughputSampler(2, 0)));\n    sampler.close();\n  });\n\n  it('should provide minimum throughput', () => {\n    let initialDate = new Date(2011, 9, 1).getTime();\n    let clock = sinon.useFakeTimers(initialDate);\n    let sampler = new GuaranteedThroughputSampler(2, 0);\n    clock = sinon.useFakeTimers(initialDate + 20000);\n\n    let expectedTags = { 'sampler.type': 'lowerbound', 'sampler.param': 0 };\n    [true, true, false].forEach(expectedDecision => {\n      let actualTags = {};\n      let decision = sampler.isSampled('testOperationName', actualTags);\n      // We asked for 2 traces per second and 0% probability for the rest.\n      // Since the test runs under one second, we expect 2 successful samples\n      // and one unsuccessful.\n      if (expectedDecision) {\n        assert.isOk(decision, 'must sample');\n        assert.deepEqual(expectedTags, actualTags);\n      } else {\n        assert.isNotOk(decision, 'must not sample');\n        assert.deepEqual({}, actualTags);\n      }\n    });\n\n    clock.restore();\n    sampler.close();\n  });\n\n  let assertValues = function assertValues(sampler, lb, rate) {\n    assert.equal(lb, sampler._lowerBoundSampler.maxTracesPerSecond);\n    assert.equal(rate, sampler._probabilisticSampler.samplingRate);\n  };\n\n  it('should not change when update() called with the same values', () => {\n    let sampler = new GuaranteedThroughputSampler(2, 1.0);\n    assertValues(sampler, 2, 1.0);\n\n    let p1 = sampler._probabilisticSampler;\n    let p2 = sampler._lowerBoundSampler;\n    let isUpdated: boolean = sampler.update(2, 1.0);\n    assert.isFalse(isUpdated);\n    assert.strictEqual(sampler._probabilisticSampler, p1);\n    assert.strictEqual(sampler._lowerBoundSampler, p2);\n    assertValues(sampler, 2, 1.0);\n  });\n\n  it('should update only lower bound', () => {\n    let sampler = new GuaranteedThroughputSampler(2, 1.0);\n    assertValues(sampler, 2, 1.0);\n\n    // should only change lower bound\n    let p1 = sampler._probabilisticSampler;\n    let p2 = sampler._lowerBoundSampler;\n    let isUpdated: boolean = sampler.update(3, 1.0);\n    assert.isTrue(isUpdated);\n    assert.strictEqual(sampler._probabilisticSampler, p1);\n    assert.strictEqual(\n      sampler._lowerBoundSampler,\n      p2,\n      'lowerbound sampler should only be updated, not recreated'\n    );\n    assertValues(sampler, 3, 1.0);\n  });\n\n  it('should update only sampling rate', () => {\n    let sampler = new GuaranteedThroughputSampler(2, 1.0);\n    assertValues(sampler, 2, 1.0);\n\n    let p1 = sampler._probabilisticSampler;\n    let p2 = sampler._lowerBoundSampler;\n    let isUpdated: boolean = sampler.update(2, 0.9);\n    assert.isTrue(isUpdated);\n    assert.isNotOk(p1 === sampler._probabilisticSampler);\n    assert.strictEqual(sampler._lowerBoundSampler, p2);\n    assertValues(sampler, 2, 0.9);\n  });\n\n  it('should become probabilistic after minimum throughput', () => {\n    let initialDate = new Date(2011, 9, 1).getTime();\n    let clock = sinon.useFakeTimers(initialDate);\n    let sampler = new GuaranteedThroughputSampler(2, 1.0);\n    clock = sinon.useFakeTimers(initialDate + 20000);\n\n    let expectedTagsLB = { 'sampler.type': 'lowerbound', 'sampler.param': 0.0 };\n    let expectedTagsProb = { 'sampler.type': 'probabilistic', 'sampler.param': 1.0 };\n\n    // The sampler is setup with 2 traces per second and 100% probability otherwise.\n    // The 100% probability takes precedence over lower-bound, so we manipulate\n    // the probability for every iteration.\n    [\n      // 100% probability triggers probabilistic sampler\n      { num: 1, probability: 1, sampled: true, tags: expectedTagsProb },\n      // 0% probability triggers lower-bound sampler\n      { num: 2, probability: 0, sampled: true, tags: expectedTagsLB },\n      // 0% probability results in sampled=false because rate limit was reached\n      { num: 3, probability: 0, sampled: false, tags: {} },\n      // 100% probability triggers probabilitic sampler again\n      { num: 4, probability: 1, sampled: true, tags: expectedTagsProb },\n    ].forEach(testCase => {\n      // override probability, and do a sanity check\n      let s = sampler._lowerBoundSampler;\n      sampler.update(2, testCase.probability);\n      assert.strictEqual(s, sampler._lowerBoundSampler, 'lower bound sampled unchanged');\n      assert.equal(sampler._probabilisticSampler.samplingRate, testCase.probability);\n\n      let expectedDecision = testCase.sampled;\n      let expectedTags = testCase.tags;\n\n      let actualTags = {};\n      let decision = sampler.isSampled('testOperationName', actualTags);\n      if (expectedDecision) {\n        assert.isOk(decision, `must sample, test case ${testCase.num}`);\n        assert.deepEqual(expectedTags, actualTags, `must match tags, test case ${testCase.num}`);\n      } else {\n        assert.isNotOk(decision, `must not sample, test case ${testCase.num}`);\n        assert.deepEqual({}, actualTags, `must not have tags, test case ${testCase.num}`);\n      }\n    });\n\n    clock.restore();\n    sampler.close();\n  });\n});\n"]}